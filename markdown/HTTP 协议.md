## HTTP/1

HTTP请求&响应组成

- 状态行
- 请求头/响应头
- 消息主体

一般来说，只有主体会压缩。

## HTTP缓存原理
浏览器第一次访问服务器资源，浏览器无缓存文件，向服务器发送请求。（中间包含DNS域名解析）

服务器有该资源，返回200 OK，实体中返回文件内容，并设置缓存过期时间、文件修改时间、根据资源内容计算出来的实体标记Entity Tag。

浏览器将该资源缓存到本地。

第二次访问。

首先根据缓存过期时间判断资源是否过期。若没过期，则不向服务器发送请求；若过期，则带上文件修改时间和ETag请求资源。

然后进行资源更新判断。服务器根据文件修改时间判断自上次请求以来，文件是否修改过；根据ETag判断文件内容自上次请求以来有没有发生变化。若都没发生变化，则直接发送304 Not Modified，浏览器依然使用Cache；若发生变化，则再次发送资源。

Request首部字段

- Cache-Control: no-cache | max-age | s-maxage | only-if-cached
- Pragma: no-cache
- if-match / if-none-match: 判断资源更新，把缓存中的ETag传给服务器
- if-modified-since: 判断资源更新，把修改时间传给服务器

Response首部字段

- Cache-Control: 设置缓存过期时间
- ETag: 设置根据资源内容生成的实体标签

只有GET请求会被缓存，POST不会

ETag在资源分布在多台服务器上时，同一资源，可能ETag不同，导致需要返回资源

## TCP/IP协议

它是一个协议族的统称，包括IP协议、IMCP协议和TCP协议。

分层

- 应用层：HTTP/FTP
- 传输层：TCP/UDP
- 网络层：ARP（地址解析协议，IP地址->MAC地址）/RARP
- 网络接口层

互联网地址：IP地址，为网络号+子网号+主机号。

域名系统：是一个数据库，可以将主机名转换成IP地址。

RFC：TCP/IP协议的标准文档。

端口号：逻辑号码，IP包所带的标记。

Socket：应用编程接口。

数据链路层的工作特性

- 为IP模块发送和接收IP数据报
- 为ARP模块发送ARP请求和接收ARP应答
- 为RARP发送RARP请求和接收RARP应答

TCP/IP的工作流程：数据链路层从ARP得到数据的传递信息，再从IP得到具体的数据信息。

![IP协议](http://ww3.sinaimg.cn/mw690/5e4d414cgw1ewba702zx1j20im0ba0uv.jpg)

最重要的是TTL（IP允许通过的最大网段数量）字段，有8位，规定数据包能穿过几个路由之后才会被抛弃。

![IP路由选择](http://ww1.sinaimg.cn/mw690/5e4d414cgw1ewba70g3nbj209e0dqdgf.jpg)

![ARP协议工作原理](http://ww2.sinaimg.cn/mw690/5e4d414cgw1ewba70uonxj20le092dgb.jpg)

#### ICMP协议（网络控制文协议）

将IP数据包不能传送的错误信息传送给主机。

- 查询报文
 + ping查询：主机是否可达，通过计算间隔时间和传送多少个包的数量
 + 子网掩码
 + 时间戳：获得当前时间
- 差错报文（不产生的情况）
 + ICMP差错报文不产生差错报文
 + 源地址为零地址、环目地址、广播地址、多播地址
 
![IP路由器选择协议](http://ww2.sinaimg.cn/mw690/5e4d414cgw1ewba719ap1j205007w74a.jpg)

#### 静态路由选择

1. 配置接口以默认方式生成路由表项，或者使用route add手动添加表项
2. ICMP报文（ICMP重定向报文）更新表项
3. 动态路由选择（只使用在路由之间）

#### RIP（路由信息协议）

分布式的基于距离向量（路由器到每一个目的网络的距离记录）的路由选择协议

router承担的工作

1. 给每一个已知路由器发送RIP请求报文，要求给出完整的路由表
2. 如果接受请求，就将自己的路由表交给请求者；如果没有，就处理IP请求表项（自己部分+跳数/没有的部分+16）
3. 接受回应，更新路由表
4. 定期更新路由表（一般为30s，只能说太频繁~）

#### OSPF（开放最短路径优先协议）

分布式链路状态（和这两个路由器都有接口的网络）协议

1. 当链路状态发生变化时，采用可靠的洪泛法，向所有的路由器发送信息（相邻的所有路由器的链路状态）
2. 最终会建立一个全网的拓扑结构图

#### TCP/IP的三次握手，四次分手

![TCP报文段](http://ww4.sinaimg.cn/mw690/5e4d414cgw1ewba720nbcj20if0c8q4g.jpg)

- ACK：确认序号有效
- RST：重置连接
- SYN：发起了一个新连接
- FIN：释放一个连接

#### 三次握手的过程（客户端我们用A表示，服务器端用B表示）

前提：A主动打开，B被动打开

![](http://ww1.sinaimg.cn/mw690/5e4d414cgw1ewba72duwkj20fy0b3gm3.jpg)

1. 在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态
2. A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态
3. B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态
4. A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。

简单来说，就是

1. 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认
2. 服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态
3. 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：`#netstat -nap | grep SYN_RECV`

#### 四次分手的过程（客户端我们用A表示，服务器端用B表示）

由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

前提：A主动关闭，B被动关闭

![](http://ww2.sinaimg.cn/mw690/5e4d414cgw1ewba72s1igj20f60b3t9a.jpg)

有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

1. A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。
2. B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。
3. B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。
4. A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。

简单来说就是

客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。

1. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
2. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。
3. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。
4. A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？

为了保证A发送的最后一个ACK报文段能够到达B
防止“已失效的连接请求报文段”出现在本连接中
OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧

三次握手流程

1. 客户端发个请求“开门呐，我要进来”给服务器
2. 服务器发个“进来吧，我去给你开门”给客户端
3. 客户端有很客气的发个“谢谢，我要进来了”给服务器

四次挥手流程

1. 客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他
2. 服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走
3. 服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）
4. 客户端发个“我知道了，我走了”，之后自己就走了

## HTTP长连接和短连接

HTTP（应用层协议）的长短连接建立在TCP（传输层协议）的长短连接上。网络层的IP协议用于解决网络路由和寻址问题，TCP用于解决建立在IP上的传递数据包问题。

HTTP协议无状态，指其对事务处理没有记忆能力，即服务器不记录连接来自哪个浏览器。

短连接：HTTP/1.0。浏览器与服务器每进行一次HTTP操作，就建立一次连接，然后断开。

长连接：HTTP/1.1的默认连接方式。请求头有`Connection: keep-alive`字段，当网页打开后，客户端与服务端之间用于传输HTTP数据的TCP连接不会关闭。如果客户端继续请求这个服务器上的文件，会使用已建立的TCP连接。`keep-alive`的时间由服务器设定。


## HTTP/2

2015年5月发布的HTTP/2，已得到诸多浏览器及服务器（Nginx & Nginx Plus）的支持。通过引进报头字段压缩和多路复用来更效复用网络资源。

HTTP/2构建在Google SPDY协议基础上，重要特性

- 二进制协议
- 针对每个域只使用一个多路重用的连接，而非一个文件一个连接
- 首部使用HPACK协议压缩（SPDY使用Gzip）
- 拥有复杂的优先级排定规则，帮助浏览器首先请求最急需的文件

### HTTP / 2协议概述
HTTP/2 提供了HTTP语义的传输优化。HTTP/2支持所有HTTP／1.1的核心特征，并且在其他方面做的更高效。

HTTP/2中基本的协议单位是帧。每个帧都有不同的类型和用途。例如，报头(HEADERS)和数据(DATA)帧组成了基本的HTTP 请求和响应；其他帧例如设置(SETTINGS)、窗口更新(WINDOW_UPDATE)和推送承诺(PUSH_PROMISE)是用来实现HTTP/2的其他功能。

请求多路复用是通过在一个流上分配多个HTTP请求响应交换来实现的。流在很大程度上是相互独立的，因此一个请求上的阻塞或终止并不会影响其他请求的处理。

流量控制和优先级能确保正确使用复用流。流量控制有助于确保只传播接受者需要使用的数据。优先级能确保有限的资源能优先被重要的请求使用。

HTTP/2添加了一种新的交互模式，即服务器能推送消息给客户端。服务器推送允许服务端预测客户端需要来发送数据给客户端，交换网络使用以阻止潜在的延迟增长。服务器通过复用一个以PUSH_PROMISE帧发送的请求来实现推送，然后服务端可以在一个单独的流里面发送响应给这个合成的请求。

帧包含的HTTP报头字段是压缩的。HTTP请求有可能是高度冗余的，因此压缩能显著减少请求和响应的大小。

### [更多](https://linux.cn/article-6551-1.html?utm_source=weibo&utm_medium=weibo)