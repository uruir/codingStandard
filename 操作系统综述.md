BIOS Basic Input/Output System

从存储设备中读起始的512 bytes，叫主引导记录（master boot record，其它地方用来分区啦~），它告诉电脑从该设备的某一分区来装载引导加载程序（boot loader，为方便管理，即使不是系统分区，也预留启动区--Linux中?）。BL有OS的信息，如内核所在位置。常用的BL有GRUB和LILO。

BIOS -> MBR -> BL -> KERNEL

kernel
内核预留自己运行所需的内存，然后通过驱动检测硬件。
内核启动init进程（1号）

init process
运行初始脚本
给出登录圣诞框

pwd  present working directory

架构
![linux的架构](http://pic002.cnblogs.com/images/2012/413416/2012092023590167.jpg)

查看系统调用（将上层的应用和下层的内核分享，库函数利用系统调用创造出模块化的功能）
```
man 2 syscalls
```
文件拥有者
```
sudo chown uruir xxx
sudo chgrp uruir xxx
```
文本流
```
ls > a.txt  //流向a.txt。有三个流stdin/stdout/stderr
echo xxx > a.txt
cat < a.txt
cat < a.txt > b.txt  //a.txt的内容流向了b.txt
cd void >& a.txt  //错误流也写入a.txt
cat < a.txt | wc  //统计a.txt里的行，词数，字符数
```
程序是菜谱，进程是做菜的过程。
```
ps  //正在运行的进程
ps -e  //全部进程
ps -o pid,ppid,cmd  
```
进程信息交流（interprocess communication）
signal。传递整数，用于系统管理相关的任务，如进程终结、中止或恢复等。SIGINT-CTRL+C; SIGQUIT-CTRL+\; SIGSTP-CTRL+Z;
后台进程
```
ping localhost > log &  //末尾加&
kill -SIGTERM -num
fg %1  //把后台任务调入前台，用CTRL+D结束输入
```
Linux用户登入后，有user ID和group ID。
用户信息保存在/etc/passwd中，组信息保存在/etc/group中，密码保存在/etc/shadow中。
命令执行过程：
![](http://pic002.cnblogs.com/images/2012/413416/2012100713481830.jpg)
shell先复制自己，9913再执行cat命令。
每个进程占用的内存分配：
![](http://pic002.cnblogs.com/images/2012/413416/2012100823484520.jpg)
- text。指令（固定大小）
- global data。全局变量（固定大小）
- stack。局部变量，以frame为单位，先进后出，最下面的帧可被读写（该帧对应的函数牌激活状态）。当最上面的帧（main）弹出时，栈空，进程结束
- heap。动态变量，用malloc产生的内存占用，向上增长。用free来释放空间，否则memory leakage。
进程附加信息：
占用内核使用的内存，这样内核就知道进程当前的状态。
fork就是复制一份text/global data/heap/stack给新进程。
当exec时，清空上面四份，根据命令重建新的四份。此时heap和stack为零。
单线程：
![](http://pic002.cnblogs.com/images/2012/413416/2012100823434181.jpg)
多线程允许一个进程存在多个控制权，让多个函数同时处于激活状态。
![](http://pic002.cnblogs.com/images/2012/413416/2012101004013240.jpg)
创建新线程时，为该线程新建一个栈，多个栈间有空白，以备栈的增长，每个线程可调用自己栈最下方的帧中参数和变量，并与其它线程共享内存中的text/global data/heap区域。因此当一个进程中任意一个栈溢出时都是stack overflow。
并发：多个窗口卖火车票。解决办法是把原先分享的两个指令构成原子操作，让竞争不存在。
多线程同步：某一时间内只允许一个线程访问某资源。通过互斥锁（mutex），条件变量（condition varibale），读写锁（reader-write lock）来同步资源。
互斥锁。全局变量，有lock & unlock两种状态。中间就是原子操作
```
/*mu is a global mutex*/

while (1) {                /*infinite loop*/
  mutex_lock(mu);           /*aquire mutex and lock it, if cannot, wait until mutex is unblocked*/
  if (i != 0) i = i - 1;
  else {
    printf("no more tickets");
    exit();
  }
  mutex_unlock(mu);         /*release mutex, make it unblocked*/
}
```
其它进程间通信
- PIPE。内核管理的一个缓冲区（buffer），可以设计成环形的数据结构。管道利用fork（父子进程）来建立，从而让两个进程连接到一个PIPE上。
![](http://pic002.cnblogs.com/images/2012/413416/2012101209015195.jpg)
关闭黑色连接，就形成两个process间（有亲缘关系的进程间）的信息流。
- FIFO。是一种特殊的文件类型，是一个file！。当一进程以读的方式打开该文件，另一进程以写方式打开该文件，那么内核就在这两个进程间建立管道。
- 传统IPC。消息队列（message queue），信号量（semaphore），共享内存（shared memory）。
消息队列与PIPE类似，只是允许多个进程放入，取出消息。
互斥锁（mutex，一）VS信号量（semaphore，多）。
共享内存是一个进程自己的global data & heap共享出来，让其它进程读写。用semaphore解决同步问题，是最高效的IPC方式。
存储设备分区
每个分区有一个分区表（partition table，黄色部分），记录分区的信息，存在于分区（绿色部分）之外。
![windows](http://images.cnitblog.com/blog/413416/201402/251719082508830.png)
![linux](http://images.cnitblog.com/blog/413416/201402/250221581092754.png)
超级区存放文件系统类型，inode数量，数据块数量等。
一个文件对应一个inode（用ls -l filename看该文件的元数据）。inode里有多个指针，连接起多个分散了的数据块。
![inode structure](http://images.cnitblog.com/blog/413416/201402/251115315292334.png)
```
cat /var/test.txt  //从根目录文件中找到var的inode，全成var的数据；从var中找到test.txt的inode，合成test.txt的inode；根据inode指示合成test.txt文件。（目录和文件都是由inode组成，这之后才是真正的数据。用```stat filename```查看文件对应的inode编号。）
```
![](http://images.cnitblog.com/blog/413416/201402/252007477914143.png)
2号inode指向根目录，10747905号inode指向var目录，var目录里的10749034号inode里存有组成test.txt的inode。所以这里根目录、var目录和test.txt文件存的都是inode。